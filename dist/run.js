"use strict";var X=Object.create;var B=Object.defineProperty;var J=Object.getOwnPropertyDescriptor;var ee=Object.getOwnPropertyNames;var te=Object.getPrototypeOf,re=Object.prototype.hasOwnProperty;var se=(r,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of ee(e))!re.call(r,n)&&n!==t&&B(r,n,{get:()=>e[n],enumerable:!(s=J(e,n))||s.enumerable});return r};var P=(r,e,t)=>(t=r!=null?X(te(r)):{},se(e||!r||!r.__esModule?B(t,"default",{value:r,enumerable:!0}):t,r));var K=P(require("picocolors"));var _=P(require("shelljs")),d=P(require("picocolors")),v=P(require("semver"));var x=P(require("picocolors"));var b=P(require("semver"));function O(r,e,t,s){if(t.length===0)return null;let n=e.changeTypes.reduce((o,u)=>(o[u.bump].push(...u.labels),o),{minor:[],major:[],patch:[]}),l=t.reduce((o,u)=>[...o,...u.labels],[]);return n.major.some(o=>l.includes(o))?s?b.default.inc(r,"premajor","rc"):b.default.inc(r,"major"):n.minor.some(o=>l.includes(o))?s?b.default.inc(r,"preminor","rc"):b.default.inc(r,"minor"):s?b.default.inc(r,"prepatch","rc"):b.default.inc(r,"patch")}function N(r,e,t,s,n){let l=e.user.changeTypes.find(a=>a.default),o=t.reduce((a,c)=>{var y,R,k;let h=e.user.changeTypes.find(w=>w.labels.some(g=>c.labels.includes(g)))||l;if(!h)return a;a.has(h.title)||a.set(h.title,{default:!1,...h,changes:[]});let C=s.getCommitUrl(e.ci.repoOwner,e.ci.repoName,c.commitHash);if(c.pullRequestNumber){let w=s.getPullRequestUrl(e.ci.repoOwner,e.ci.repoName,c.pullRequestNumber),g=`- ${c.title} [[#${c.pullRequestNumber}](${w})]`;(y=a.get(h.title))==null||y.changes.push(g)}else{let w=`- ${c.title} ([${c.commitHash.substring(0,7)}](${C}))`;(R=a.get(h.title))==null||R.changes.push(w)}return(k=a.get(h.title))==null||k.changes.push(),a},new Map),u=Array.from(o.values()).sort((a,c)=>(c.weight||(c.default?-1:0))-(a.weight||(a.default?-1:0))).map(a=>`### ${a.title}

${a.changes.filter(c=>c!=="").join(`
`)}`).join(`

`),i=s.getReleaseUrl(e.ci.repoOwner,e.ci.repoName,r),f=new Date().toISOString().split("T")[0],p=`## [${r}](${i}) - ${f}

`;if(n){let a=`### \u2764\uFE0F Thanks to all contributors! \u2764\uFE0F

${t.map(c=>`@${c.author}`).sort().filter((c,h,C)=>C.indexOf(c)===h).filter(c=>!c.endsWith("[bot]")).join(", ")}`;p+=`${a}

`}return p+=`${u}`,p}function U(r,e,t,s){var u;let n=t.replace(`# Changelog

`,""),l=[],o="## [";for(;n.includes(o);){let i=n.indexOf(o),f=n.indexOf(o,i+1);f===-1&&(f=n.length);let p=n.slice(i,f).trim(),a=(u=p.match(/\[(.*?)\]/))==null?void 0:u[1];if(!a)throw new Error("Could not find version in changelog section");l.push({version:a,section:p}),n=n.slice(f)}return l=l.filter(i=>i.version!==e).filter(i=>b.default.compare(i.version,r)!==1).filter(i=>b.default.prerelease(i.version)===null||!i.version.replace(/^v/,"").startsWith(e.replace(/^v/,""))),l.push({version:e,section:s}),l=l.sort((i,f)=>b.default.compare(f.version,i.version)),`# Changelog

${l.map(i=>i.section).join(`

`)}
`}function L(r){let e=/(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?/,t=r.match(e);if(!t)throw new Error(`Could not extract version from commit message: ${r}`);return t[0]}var E=require("fs");async function G(r){let{config:e,forge:t,git:s,exec:n,changes:l,latestVersion:o,nextVersion:u,pullRequestBranch:i,shouldBeRC:f}=r;console.log("# Preparing release pull-request for version:",x.default.green(u),"...");let p={exec:n,latestVersion:o,nextVersion:u,changes:l},{releaseBranch:a}=e.ci;if((await s.branch()).all.includes(`remotes/origin/${i}`)){console.log(x.default.yellow(`Branch "${i}" already exists, checking it out.`)),await s.checkout([i]);try{await s.pull(i)}catch(g){console.log(x.default.yellow(`Error pulling "${i}" branch. Maybe it does not exist yet?`),g)}await s.merge([`origin/${a}`,"-m",`Merge branch 'origin/${a}' into '${i}'`,"--no-edit"])}else console.log(x.default.yellow(`Branch "${i}" does not exist yet, creating it.`)),await s.checkout(["-B",i,"--track"]);if(e.user.beforePrepare&&(console.log("# Running beforePrepare hook"),await e.user.beforePrepare(p)===!1)){console.log("# beforePrepare hook returned false, skipping prepare.");return}let h="";await E.promises.stat("CHANGELOG.md").catch(()=>!1)&&(h=await E.promises.readFile("CHANGELOG.md","utf-8"));let C=N(u,e,l,t,!0),y=U(o,u,h,C);console.log("# Updating CHANGELOG.md"),await E.promises.writeFile("CHANGELOG.md",y);let{isClean:R}=await s.status();if(R()||(await s.add("."),await s.commit(`${e.ci.releasePrefix} ${u}`),await s.push(["-u","origin",i])),!e.ci.repoOwner||!e.ci.repoName)throw new Error("Missing repoOwner or repoName");let k=e.user.getReleaseDescription?await e.user.getReleaseDescription(p):`This PR was opened by the [ready-release-go](https://github.com/woodpecker-ci/plugin-ready-release-go) plugin. When you're ready to do a release, you can merge this pull-request and a new release with version \`${u}\` will be created automatically. If you're not ready to do a release yet, that's fine, whenever you add more changes to \`${a}\` this pull-request will be updated.

## Options

- [${f?"x":" "}] Mark this version as a release candidate

`+N(u,e,l,t,!1);console.log("# Creating release pull-request");let w=await t.createOrUpdatePullRequest({owner:e.ci.repoOwner,repo:e.ci.repoName,title:`${e.ci.releasePrefix} ${u}`,description:k,draft:!0,sourceBranch:i,targetBranch:a});e.user.afterPrepare&&(console.log("# Running afterPrepare hook"),await e.user.afterPrepare(p)),console.log("# Successfully prepared release pull-request: ",w),console.log("# Pull-request created")}var A=P(require("picocolors"));async function F({config:r,exec:e,forge:t,changes:s,useVersionPrefixV:n,latestVersion:l,nextVersion:o,shouldBeRC:u}){let i={exec:e,latestVersion:l,nextVersion:o,changes:s};if(r.user.beforeRelease&&(console.log("# Running beforeRelease hook"),await r.user.beforeRelease(i)===!1))return;if(!r.ci.repoOwner||!r.ci.repoName)throw new Error("Missing repoOwner or repoName");let f=N(o,r,s,t,!0),p=r.user.getReleaseDescription?await r.user.getReleaseDescription(i):f;console.log("# Creating release");let a=n&&!o.startsWith("v")?`v${o}`:o,{releaseLink:c}=await t.createRelease({owner:r.ci.repoOwner,repo:r.ci.repoName,tag:a,description:p,name:o,prerelease:u});if(console.log(A.default.green("# Successfully created release:"),c),r.user.commentOnReleasedPullRequests){console.log("# Adding release comments to pull-requests");for await(let{pullRequestNumber:h}of s){if(!h)continue;let C=`\u{1F389} This PR is included in version ${o} \u{1F389}

The release is now available [here](${c})

Thank you for your contribution. \u2764\uFE0F\u{1F4E6}\u{1F680}`;await t.addCommentToPullRequest({owner:r.ci.repoOwner,repo:r.ci.repoName,pullRequestNumber:h,comment:C})}}r.user.afterRelease&&(console.log("# Running afterRelease hook"),await r.user.afterRelease(i))}function oe(r,e){var t;return((t=r.match(new RegExp(`-\\s\\[(.)\\]\\s${e}`,"i")))==null?void 0:t[1])==="x"}function S(r){return r?{nextVersionShouldBeRC:oe(r.description,"Mark this version as a release candidate")}:{nextVersionShouldBeRC:!1}}async function H({git:r,forge:e,config:t}){var w;t.ci.debug&&(process.env.DEBUG="simple-git");let s={exec:_.default.exec};if(console.log("# Event type:",d.default.green(t.ci.eventType)),console.log("# Commit message was:",d.default.green(t.ci.commitMessage)),t.ci.eventType!=="push"){console.log(d.default.yellow("# Not a push event, skipping."));return}let n=await e.getGitCredentials();await r.addConfig("user.name",n.username),await r.addConfig("user.email",n.email);let l=await r.getRemotes(!0);if(l.length<1){console.log(d.default.yellow("# No remotes found, skipping."));return}if(!l[0].refs.push.includes("@")){let g=l[0].refs.push.replace("://",`://${n.username}:${n.password}@`);await r.removeRemote(l[0].name),await r.addRemote(l[0].name,g)}let{releaseBranch:o}=t.ci;await r.fetch(["--unshallow","--tags"]),await r.checkout(o),await r.branch(["--set-upstream-to",`origin/${o}`]),await r.pull();let u=(w=t.ci.commitMessage)==null?void 0:w.startsWith(t.ci.releasePrefix),i=`${t.ci.pullRequestBranchPrefix}${o}`,f=!1,p=t.user.getNextVersion?await t.user.getNextVersion(s):null;if(u)p=L(t.ci.commitMessage),f=v.default.prerelease(p)!==null;else{let g=await e.getPullRequest({owner:t.ci.repoOwner,repo:t.ci.repoName,sourceBranch:i,targetBranch:o});f=S(g).nextVersionShouldBeRC}let a=await r.tags(["--sort=-creatordate"]);if(!a.latest&&a.all.length>0){console.log(d.default.yellow("# Latest tag not found, but tags exist, skipping."));return}let c=a.latest||"0.0.0";a.latest?console.log("# Lastest tag is:",d.default.green(c)):console.log(d.default.green(`# No tags found. Starting with first tag: ${c}`));let h=await r.log(c==="0.0.0"?[o]:{from:c,to:o,symmetric:!1});if(v.default.prerelease(c)!==null&&!f){let g=a.all.filter(m=>v.default.valid(m)&&v.default.prerelease(m)===null).sort(v.default.rcompare);if(g.length>0){let m=g[0];console.log("# Adding commits since last none rc tag:",d.default.green(m),"and",d.default.green(o)),h=await r.log({from:m,to:o,symmetric:!1})}}if(h.total===0){console.log(d.default.yellow("# No untagged commits found, skipping."));return}console.log("# Found",d.default.green(h.total),"untagged commits");let C=t.user.useVersionPrefixV===void 0?c.startsWith("v"):t.user.useVersionPrefixV,y=c.replace(/^v/,""),R=[];for await(let g of h.all){if(g.message.startsWith(t.ci.releasePrefix))continue;let m=await e.getPullRequestFromCommit({owner:t.ci.repoOwner,repo:t.ci.repoName,commitHash:g.hash});if(t.user.skipCommitsWithoutPullRequest&&!m){console.log(d.default.yellow("# No pull-request found for commit, skipping."),`${g.hash}: "${g.message}"`);continue}if(m!=null&&m.labels.some(Q=>{var I;return(I=t.user.skipLabels)==null?void 0:I.includes(Q)})){console.log(d.default.yellow("# Skipping commit / PR by label:"),`${g.hash}: "${g.message}"`);continue}R.push({commitHash:g.hash,author:(m==null?void 0:m.author)||g.author_name,title:(m==null?void 0:m.title)||g.message,labels:(m==null?void 0:m.labels)||[],pullRequestNumber:m==null?void 0:m.number})}if(t.ci.debug&&console.log(d.default.yellow("changes"),R),u||(p=O(y,t.user,R,f)),!p){console.log(d.default.yellow("# No changes or unable to bump semver version."));return}console.log("# Next version will be:",d.default.green(p));let k={config:t,forge:e,git:r,changes:R,nextVersion:p,latestVersion:y,useVersionPrefixV:C,pullRequestBranch:i,shouldBeRC:f,exec:_.default.exec};if(u){console.log(d.default.green("# Release commit detected.")),console.log("# Now releasing version:",d.default.green(p)),await F(k),console.log("# Successfully released version:",d.default.green(p));return}console.log("# Push to release branch detected."),await G(k)}var D=P(require("path")),j=require("fs");function M(){return{configFile:process.env.PLUGIN_CONFIG_FILE,eventType:process.env.CI_PIPELINE_EVENT,releaseBranch:process.env.PLUGIN_RELEASE_BRANCH||process.env.CI_REPO_DEFAULT_BRANCH,commitMessage:process.env.CI_COMMIT_MESSAGE,forgeType:process.env.CI_FORGE_TYPE,githubToken:process.env.PLUGIN_GITHUB_TOKEN,gitEmail:process.env.PLUGIN_GIT_EMAIL,repoOwner:process.env.CI_REPO_OWNER,repoName:process.env.CI_REPO_NAME,pullRequestBranchPrefix:process.env.PLUGIN_PULL_REQUEST_BRANCH_PREFIX,debug:process.env.PLUGIN_DEBUG==="true"}}function W(){var t,s;let r=process.env.GITHUB_EVENT_NAME,e=process.env.INPUT_GITHUB_TOKEN||process.env.GITHUB_TOKEN;if(!e)throw new Error("Please provide a GitHub token");return{configFile:process.env.INPUT_CONFIG_FILE,eventType:r,releaseBranch:process.env.INPUT_RELEASE_BRANCH||process.env.CI_REPO_DEFAULT_BRANCH,commitMessage:process.env.CI_COMMIT_MESSAGE,forgeType:"github",githubToken:e,gitEmail:process.env.INPUT_GIT_EMAIL,repoOwner:process.env.GITHUB_REPOSITORY_OWNER,repoName:(s=(t=process.env.GITHUB_REPOSITORY)==null?void 0:t.split("/"))==null?void 0:s[1],pullRequestBranchPrefix:process.env.INPUT_PULL_REQUEST_BRANCH_PREFIX,debug:process.env.INPUT_DEBUG==="true"}}var ne={changeTypes:[{title:"\u{1F4A5} Breaking changes",labels:["breaking"],bump:"major",weight:3},{title:"\u{1F512} Security",labels:["security"],bump:"patch",weight:2},{title:"\u2728 Features",labels:["feature","feature \u{1F680}\uFE0F"],bump:"minor",weight:1},{title:"\u{1F4C8} Enhancement",labels:["enhancement","refactor","enhancement \u{1F446}\uFE0F"],bump:"minor"},{title:"\u{1F41B} Bug Fixes",labels:["bug","bug \u{1F41B}\uFE0F"],bump:"patch"},{title:"\u{1F4DA} Documentation",labels:["docs","documentation","documentation \u{1F4D6}\uFE0F"],bump:"patch"},{title:"Misc",labels:["misc","chore \u{1F9F0}"],bump:"patch",default:!0}],skipLabels:["skip-release","skip-changelog","regression"],skipCommitsWithoutPullRequest:!0,commentOnReleasedPullRequests:!0},q={eventType:"manual",releaseBranch:"main",commitMessage:"",forgeType:"github",githubToken:"",gitEmail:"",repoOwner:"",repoName:"",pullRequestBranchPrefix:"next-release/",releasePrefix:"\u{1F389} Release",debug:!1};async function V(){let r={},e=q;if(process.env.CI==="woodpecker")console.log("# CI: Woodpecker"),e={...q,...M()};else if(process.env.GITHUB_ACTIONS==="true")console.log("# CI: GitHub Actions"),e={...q,...W()};else throw new Error("Unsupported CI type");let t=e.configFile||D.default.join(process.cwd(),"release-config.ts");if(await j.promises.stat(t).then(()=>!0).catch(()=>!1)){console.log("# Loading config from",t,"...");let s=await import(t);Object.assign(r,s.default),console.log("# Loaded config from",t)}return{user:{...ne,...r},ci:e}}var T=class{};var z=require("@octokit/rest"),$=class extends T{accessToken;email;octokit;constructor(e,t){super(),this.email=t,this.accessToken=e,this.octokit=new z.Octokit({auth:e})}async createOrUpdatePullRequest(e){let t=await this.octokit.pulls.list({owner:e.owner,repo:e.repo,head:`${e.owner}:${e.sourceBranch}`});return t.data.length>0?{pullRequestLink:(await this.octokit.pulls.update({owner:e.owner,repo:e.repo,pull_number:t.data[0].number,title:e.title,draft:e.draft,head:e.sourceBranch,base:e.targetBranch,body:e.description})).data._links.html.href}:{pullRequestLink:(await this.octokit.pulls.create({owner:e.owner,repo:e.repo,title:e.title,draft:e.draft,head:e.sourceBranch,base:e.targetBranch,body:e.description})).data._links.html.href}}async createRelease(e){return{releaseLink:(await this.octokit.repos.createRelease({owner:e.owner,repo:e.repo,tag_name:e.tag,name:e.name,body:e.description,prerelease:e.prerelease})).data.html_url}}async getGitCredentials(){return{email:this.email,username:"oauth",password:this.accessToken}}async getPullRequestFromCommit(e){var s;let t=await this.octokit.repos.listPullRequestsAssociatedWithCommit({owner:e.owner,repo:e.repo,commit_sha:e.commitHash});if(t.data.length!==0)return{number:t.data[0].number,title:t.data[0].title,description:t.data[0].body||"",author:((s=t.data[0].user)==null?void 0:s.login)||"",labels:t.data[0].labels.map(n=>n.name)}}async getPullRequest(e){var n;let t=await this.octokit.pulls.list({owner:e.owner,repo:e.repo,head:`${e.owner}:${e.sourceBranch}`});if(t.data.length>1)throw new Error("Found more than one pull request to release. Please close all but one.");if(t.data.length===0)return;let s=t.data[0];return{number:s.number,title:s.title,description:s.body||"",author:((n=s.user)==null?void 0:n.login)||"",labels:s.labels.map(l=>l.name)}}async addCommentToPullRequest(e){await this.octokit.issues.createComment({owner:e.owner,repo:e.repo,issue_number:e.pullRequestNumber,body:e.comment})}getRepoUrl(e,t){return`https://github.com/${e}/${t}`}getCommitUrl(e,t,s){return`https://github.com/${e}/${t}/commit/${s}`}getIssueUrl(e,t,s){return`https://github.com/${e}/${t}/issues/${s}`}getPullRequestUrl(e,t,s){return`https://github.com/${e}/${t}/pull/${s}`}getReleaseUrl(e,t,s){return`https://github.com/${e}/${t}/releases/tag/${s}`}async getPullRequestComments(e,t,s){return(await this.octokit.paginate(this.octokit.issues.listComments,{owner:e,repo:t,issue_number:s})).map(l=>{var o;return{id:l.id.toString(),body:l.body,author:(o=l.user)==null?void 0:o.login,createdAt:l.created_at}})}};async function Z(r){if(r.ci.forgeType==="github"){if(!r.ci.githubToken)throw new Error("Please provide a Github token");if(!r.ci.gitEmail)throw new Error("Please provide a Git email");return new $(r.ci.githubToken,r.ci.gitEmail)}throw new Error("Forge type not supported: "+r.ci.forgeType)}var Y=P(require("simple-git"));async function ie(){try{let r=await V(),e=await Z(r),t=(0,Y.default)();await H({git:t,forge:e,config:r})}catch(r){console.error(K.default.red(r.message)),process.exit(1)}}ie();
